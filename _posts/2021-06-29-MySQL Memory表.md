---
layout: post
title:  "MySQL内存表"
subtitle: "Memory表简单介绍"
date:   2021-06-29 16:31:29 +0900
categories: MySQL
author:  "张鑫"
tags:
  - Memory表
---

# MySQL memory存储引擎

### 存储方式
Memory引擎采用堆组织表（Heap Organizied Table）方式，数据和索引分别单独存放，索引上保存数据位置，主键索引为哈希索引，执行范围查询无法利用主键索引。
 
### InnoDB与Memory
* InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
* 当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；
* 数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；
* InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的；
* InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。
 
### 内存表的Btree索引
内存表也可以用Btree索引，创建语句如下：

```sql
alter table t1 add index a_btree_index using btree (id);
```
这时表的索引组织形式：
![avatar](/myblog/img/memory_index.jpg)

为什么不建议在生产环境使用内存表：
1. 锁粒度问题
2. 数据持久化问题

### 内存表的锁
内存表只支持表锁，不支持行锁，并发很差

### 数据持久化问题
* 数据无法持久化；
* 同时在主从架构情况下，可能导致主备断开，如备库重启后，内存表清除，主库再执行内存表操作时，备库找不到该表；
* 在双M架构下，一个库重启，会执行delete from t1，导致另一个库中的内存表被清空。

因此在使用内存表的时候，如果有特殊需求，建议可以用内存临时表代替。避免掉内存表的不足。


### 问题
如果维护的 MySQL 系统里有内存表，怎么避免内存表突然丢数据，然后导致主备同步停止的情况。主库的存储引擎暂时不能修改。
通过如下方式，避免备库重启，数据丢失
```
set sql_log_bin=off;
alter table tbl_name engine=innodb;
```