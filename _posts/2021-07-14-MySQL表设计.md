---
layout: post
title:  "MySQL表设计"
subtitle: "如何设计MySQL数据库表"
date:   2021-07-14 21:31:29 +0900
categories: MySQL
author:  "张鑫"
tags:
  - 表设计
---

# 表设计

### 工程表结构设计实战

* 每张表一定要有一个主键（方法有自增主键设计、UUID 主键设计、业务自定义生成主键）；
* 消除冗余数据存在的可能。

### 自增主键设计

真正的核心业务表，一定不要用自增键做主键，主要有 6 个原因：
1. 自增存在回溯问题；
2. 自增值在服务器端产生，存在并发性能问题；受参数 innodb_autoinc_lock_mode 的影响，想获得自增值的最大并发性能，把参数 innodb_autoinc_lock_mode 设置为2。
3. 自增值做主键，只能在当前实例中保证唯一，不能保证全局唯一；
4. 公开数据值，容易引发安全问题，例如知道地址http://www.example.com/User/10/，很容猜出 User 有 11、12 依次类推的值，容易引发数据泄露；
5. MGR（MySQL Group Replication） 可能引起的性能问题；
6. 分布式架构设计问题。

所以建议使用UUID 做主键或业务自定义生成主键。

### UUID主键设计
MySQL 数据库遵循 DRFC 4122 命名空间版本定义的 Version 1规范，可以通过函数 UUID自动生成36字节字符。如：

```sql
mysql> SELECT UUID();
+--------------------------------------+
| UUID()                               |
+--------------------------------------+
| e0ea12d4-6473-11eb-943c-00155dbaa39d |
+--------------------------------------+
```
根据 Version 1的规范，MySQL中的 UUID 由以下几个部分组成：

```
UUID = 时间低（4字节）- 时间中高+版本（4字节）- 时钟序列 - MAC地址
```
前 8 个字节中，60 位用于存储时间，4 位用于 UUID 的版本号，其中时间是从 1582-10-15 00：00：00.00 到现在的100ns 的计数。

60 位的时间存储中，其存储分为：
* 时间低位（time-low），占用 12 位；
* 时间中位（time-mid），占用 2 字节，16 位；
* 时间高位（time-high），占用 4 字节，32 位；

**需要特别注意的是，在存储时间时，UUID 是根据时间位逆序存储**，也就是低时间低位存放在最前面，高时间位在最后，即 UUID 的前 4 个字节会随着时间的变化而不断“随机”变化，并非单调递增。而非随机值在插入时会产生离散 IO，从而产生性能瓶颈。这也是 UUID 对比自增值最大的弊端。

为了解决这个问题，MySQL 8.0 推出了函数 UUID_TO_BIN，它可以把 UUID 字符串：
* 通过参数将时间高位放在最前，解决了 UUID 插入时乱序问题；
* 去掉了无用的字符串"-"，精简存储空间；
* 将字符串其转换为二进制值存储，空间最终从之前的 36 个字节缩短为了 16 字节。

将之前的 UUID 字符串 e0ea12d4-6473-11eb-943c-00155dbaa39d 通过函数 UUID_TO_BIN 进行转换，得到二进制值：
```sql
SELECT UUID_TO_BIN('e0ea12d4-6473-11eb-943c-00155dbaa39d',TRUE) as UUID_BIN;
+------------------------------------+
| UUID_BIN                           |
+------------------------------------+
| 0x11EB6473E0EA12D4943C00155DBAA39D |
+------------------------------------+
1 row in set (0.00 sec)
```

除此之外，MySQL 8.0 也提供了函数 BIN_TO_UUID，支持将二进制值反转为 UUID 字符串。
这样建表语句就成了：

```sql
CREATE TABLE User (
    id  BINARY(16) NOT NULL,
    ...
    uuid CHAR(36) AS (BIN_TO_UUID(id)),
    PRIMARY KEY(id)
);
```
数据插入语句：

```sql
INSERT INTO User VALUES (UUID_TO_BIN(UUID(),TRUE),......);
```

使用mysql 8.0提供的排序UUID优势：
1. 性能比自增id性能更好；
2. 能保证全局唯一，收益大于自增ID；
3. 不足之处就是自增id占8字节，排序UUID占16字节，但实际空间增长不足1%。

### 业务自定义生成主键
UUID 虽好，但是在分布式数据库场景下，主键还需要加入一些额外的信息，这样才能保证后续二级索引的查询效率，分布式数据库架构，仅用 UUID 做主键依然是不够的。

建议设计为：

```
PK = 时间字段 + 随机码（可选） + 业务信息1 + 业务信息2 ......
```

例如淘宝订单表，订单号显然是订单表的主键，但如果你以为订单号是自增整型，那就大错特错了。因为如果仔细观察的话，可以发现所有订单号的后 6 位都是相同的，跟用户ID相关，前 14 位是时间相关字段，这样能保证插入的自增性，又能同时保留业务的相关信息作为后期的分布式查询。