---
layout: post
title:  "MySQL客户端kill原理"
date:   2021-06-17 12:31:29 +0900
categories: MySQL
---

# MySQL kill语句
### kill类型

一个是 kill query + 线程 id，表示终止这个线程中正在执行的语句；
一个是 kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接；
当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的

### kill query执行内容：

当用户执行 kill query thread_id_B 时，MySQL 里处理 kill 命令的线程做了两件事：
1. 把 session的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；
2. 给 session的执行线程发一个信号。

**为什么发信号：**

session处于锁等待状态，如果只是把 session 的线程状态设置 THD::KILL_QUERY，线程并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让 session退出等待，来处理这个 THD::KILL_QUERY 状态。

**隐含三层意思：**

1. 一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；
2. 如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；
3. 语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。

线程被kill了，已经断开了连接，但是在服务端show processlist还能看到该线程，显示killed：

**在执行kill query命令时：**

在实现上，等行锁时，使用的是 pthread_cond_timedwait 函数，这个等待状态可以被唤醒。线程的等待逻辑是这样的：每 10 毫秒判断一下是否可以进入 InnoDB 执行，如果不行，就调用 nanosleep 函数进入 sleep 状态。
线程的状态已经被设置成了 KILL_QUERY，但是在这个等待进入 InnoDB 的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。

**当执行kill connection时：**

1. 把线程状态设置为 KILL_CONNECTION；
2. 关掉线程的网络连接。

```
如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。
```
客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢？
只有等到满足进入 InnoDB 的条件后，session的查询语句继续执行，然后才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。

### 显示killed有两种可能：

1. 线程没有执行到判断线程状态的逻辑
2. 终止逻辑耗时较长：
    1. 超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。
    2. 大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。
    3. DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。

### 关于客户端误解

1. 客户端执行 Ctrl+C，是 MySQL 客户端另外启动一个连接，然后发送一个 kill query 命令。但是客户端已经关闭。
2. 如果库里面的表特别多，连接就会很慢
    1. 当一个库中的表个数非常多的时候，客户端需要花比较多的时间用于将库和库表构建一个本地的哈希表。这块比较花时间，可在连接命令中用-A参数关掉这个自动补全功能；
3. 连接命令中-quick（-q）参数，是让客户端变得更快，而非服务器端

**MySQL客户端发送请求后，接收服务端返回结果有两种方式：**

* 一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。
* 另一种是不缓存，读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。

加上-quick参数之后，采用第二种不缓存的方式，本地处理得慢，就会导致服务端阻塞，让服务器变慢。